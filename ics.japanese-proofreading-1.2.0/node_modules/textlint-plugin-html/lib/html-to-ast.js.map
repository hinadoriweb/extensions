{"version":3,"sources":["../src/html-to-ast.js"],"names":["removeUnusedProperties","node","forEach","key","hasOwnProperty","mapNodeType","parent","parentNode","tagName","type","mappedType","tagNameToType","nodeTypes","parse","html","ast","hast","src","StructuredSource","tr","notLeaf","position","rangeToLocation","length","start","line","column","end","positionCompensated","range","locationToRange","loc","raw","slice","properties","href","url"],"mappings":"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","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport hast from \"hast\";\nimport traverse from \"traverse\";\nimport StructuredSource from \"structured-source\";\nimport {nodeTypes, tagNameToType} from \"./mapping\";\n/**\n * Remove undocumented properties on TxtNode from node\n * @param {TxtNode} node already has loc,range\n */\nfunction removeUnusedProperties(node) {\n    if (typeof node !== \"object\") {\n        return;\n    }\n    [\"position\"].forEach(function (key) {\n        if (node.hasOwnProperty(key)) {\n            delete node[key];\n        }\n    });\n}\nfunction mapNodeType(node, parent) {\n    if (parent) {\n        let parentNode = parent.parent.node;\n        if (parentNode.tagName === \"script\" || parentNode.tagName === \"style\") {\n            return \"CodeBlock\";\n        }\n    }\n    if (node.tagName && node.type === \"element\") {\n        let mappedType = tagNameToType[node.tagName];\n        if (mappedType) {\n            // p => Paragraph...\n            return mappedType;\n        } else {\n            // other element is \"Html\"\n            return \"Html\";\n        }\n    } else {\n        // text => Str\n        return nodeTypes[node.type];\n    }\n}\nexport function parse(html) {\n    const ast = hast.parse(html);\n    const src = new StructuredSource(html);\n    const tr = traverse(ast);\n    tr.forEach(function (node) {\n        if (this.notLeaf) {\n            // avoid conflict <input type=\"text\" />\n            // AST node has type and position\n            if (node.type && node.position) {\n                // case: element => Html or ...\n                node.type = mapNodeType(node, this.parent);\n            } else if (node.type === \"root\") {\n                // FIXME: workaround, should fix hast\n                node.type = nodeTypes[node.type];\n                const position = src.rangeToLocation([0, html.length]);\n                // reverse adjust\n                node.position = {\n                    start: {line: position.start.line, column: position.start.column + 1},\n                    end: {line: position.end.line, column: position.end.column + 1}\n                };\n            }\n            // Unknown type\n            if (typeof node.type === \"undefined\") {\n                node.type = \"UNKNOWN\";\n            }\n            // map `range`, `loc` and `raw` to node\n            if (typeof node.position === \"object\") {\n                let position = node.position;\n                // TxtNode's line start with 1\n                // TxtNode's column start with 0\n                let positionCompensated = {\n                    start: {line: position.start.line, column: position.start.column - 1},\n                    end: {line: position.end.line, column: position.end.column - 1}\n                };\n                let range = src.locationToRange(positionCompensated);\n                node.loc = positionCompensated;\n                node.range = range;\n                node.raw = html.slice(range[0], range[1]);\n            }\n            // map `url` to Link node\n            if (node.type === \"Link\" && typeof node.properties.href !== \"undefined\") {\n                node.url = node.properties.href;\n            }\n        }\n        removeUnusedProperties(node);\n    });\n    return ast;\n}\n\n"],"file":"html-to-ast.js"}