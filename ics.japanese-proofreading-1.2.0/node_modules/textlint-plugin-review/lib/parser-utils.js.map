{"version":3,"sources":["../src/parser-utils.js"],"names":["parseBlockArgs","argsText","offset","argRegex","args","openIndex","closeIndex","findCloseBracket","push","value","slice","startColumn","findInlineTag","text","match","contentStartIndex","index","length","contentCloseIndex","rawContent","substr","tag","name","content","raw","fullText","precedingText","followingText","character","fromIndex","indexOf","createNodeFromChunk","chunk","type","Syntax","createNodeFromLinesInChunk","lines","firstLine","lastLine","chunkStartIndex","startIndex","endIndex","range","loc","start","line","lineNumber","column","end","createNodeFromLine","isComment","createInlineNode","contextFromLine","createCommentNodeFromLine","node","Comment","createStrNode","context","Str","unescapeValue","unescapeBraces","replace","unescapeBrackets","offsetContext","originalContext","newContext","Object","assign","contextNeedsUnescapeBraces","contextNeedsUnescapeBrackets"],"mappings":"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","sourcesContent":["// LICENSE : MIT\n'use strict';\nimport assert from 'assert';\nimport { Syntax } from './mapping';\n\n/**\n * parse arguments of a block like \"[foo][This is foo]\".\n * @param {string} argsText - String to parse\n * @param {number} offset - Offset index where the args starts with in the line\n * @return {[Arg]} Array of Args\n */\nexport function parseBlockArgs(argsText, offset) {\n  const argRegex = /\\[(.*?)\\]/g;\n  const args = [];\n\n  let openIndex = 0;\n  while (argsText[openIndex] === '[') {\n    let closeIndex = findCloseBracket(argsText, ']', openIndex);\n\n    args.push({\n      value: argsText.slice(openIndex + 1, closeIndex),\n      startColumn: offset + openIndex + 1,\n    });\n\n    openIndex = closeIndex + 1;\n  }\n\n  return args;\n}\n\n/**\n * find inline tag from text\n * @param {string} text - Text to parse\n * @return {Tag} the first Tag object if inline tag found, otherwise null\n */\nexport function findInlineTag(text) {\n  const match = text.match(/@<(\\w+)>\\{/);\n  if (!match) {\n    return null; // inline tag not found\n  }\n\n  // We need to ignore escaped closing brace \\}.\n  // As look-behind expression is relatively new, use indexOf()\n  let contentStartIndex = match.index + match[0].length;\n  let closeIndex = findCloseBracket(text, '}', contentStartIndex);\n  if (closeIndex < 0) {\n    return null; // not found\n  }\n\n  const contentCloseIndex = closeIndex - 1;\n  const rawContent = text.substr(contentStartIndex, contentCloseIndex - contentStartIndex + 1);\n  const tag = {\n    name: match[1],\n    content: {\n      raw: rawContent,\n      index: contentStartIndex - match.index,\n    },\n    fullText: text.substr(match.index, closeIndex - match.index + 1),\n    precedingText: text.substr(0, match.index),\n    followingText: text.substr(closeIndex + 1),\n  };\n\n  return tag;\n}\n\nfunction findCloseBracket(text, character, fromIndex=0) {\n  let closeIndex;\n  while (true) {\n    closeIndex = text.indexOf(character, fromIndex);\n    if (closeIndex < 0) {\n      break; // closing } not found. this is normal string not a inline tag\n    }\n\n    if (text[closeIndex - 1] !== '\\\\') {\n      break; // found closing } which is not escaped\n    }\n\n    fromIndex = closeIndex + 1;\n  }\n\n  return closeIndex;\n}\n\n/**\n * create TxtNode from chunk.\n * @param {Chunk} chunk - A chunk\n * @param {string} [type=chunk.type] - Type of node\n * @return {TxtNode} Created TxtNode\n */\nexport function createNodeFromChunk(chunk, type) {\n  type = type || Syntax[chunk.type];\n  return createNodeFromLinesInChunk(type, chunk.lines, chunk);\n}\n\n/**\n * create TxtNode from lines in a chunk.\n * @param {string} type - Type of node\n * @param {[Line]} lines - lines in a chunk\n * @param {Chunk} chunk - A chunk\n * @return {TxtNode} Created TxtNode\n */\nexport function createNodeFromLinesInChunk(type, lines, chunk) {\n  const firstLine = lines[0];\n  const lastLine = lines[lines.length - 1];\n  const chunkStartIndex = chunk.lines[0].startIndex;\n  const startIndex = firstLine.startIndex;\n  const endIndex = lastLine.startIndex + lastLine.text.length;\n  const text = chunk.raw.slice(startIndex - chunkStartIndex, endIndex - chunkStartIndex);\n\n  return {\n    type: type,\n    raw: text,\n    range: [startIndex, endIndex],\n    loc: {\n      start: {\n        line: firstLine.lineNumber,\n        column: 0,\n      },\n      end: {\n        line: lastLine.lineNumber,\n        column: lastLine.text.length,\n      },\n    },\n  };\n}\n\n/**\n * create TxtNode from single line.\n * @param {Line} line - A line\n * @param {string} type - Type of node\n * @return {TxtNode} Created TxtNode\n */\nexport function createNodeFromLine(type, line) {\n  assert(!line.isComment);\n  return createInlineNode(type, line.text, contextFromLine(line));\n}\n\n/**\n * create comment TxtNode from single line.\n * @param {Line} line - A line\n * @return {TxtNode} Created TxtNode\n */\nexport function createCommentNodeFromLine(line) {\n  assert(line.isComment);\n  const node = createInlineNode(Syntax.Comment, line.text, contextFromLine(line));\n  let match;\n  if (match = line.text.match(/^#@#\\s*(.*)/)) {\n    node.value = match[1];\n  } else if (match = line.text.match(/^#@warn\\((.*)\\)/)) {\n    node.value = match[1];\n  } else {\n    node.value = line.text;\n  }\n\n  return node;\n}\n\n/**\n * create Str TxtNode.\n * @param {string} raw - Raw text of node\n * @param {Context} context - context of the node\n * @return {TxtNode} Created TxtNode\n */\nexport function createStrNode(raw, context) {\n  const node = createInlineNode(Syntax.Str, raw, context);\n  node.value = unescapeValue(raw, context);\n  return node;\n}\n\n/**\n * unescape value considering context\n * @param {string} value - Value to unescape\n * @param {Context} context - context of unescape\n * @return {string} Unescaped value\n */\nexport function unescapeValue(value, context) {\n  if (context.unescapeBraces) {\n    value = value.replace(/\\\\\\}/g, '}');\n  }\n\n  if (context.unescapeBrackets) {\n    value = value.replace(/\\\\\\]/g, ']');\n  }\n\n  return value;\n}\n\n/**\n * create inline TxtNode.\n * @param {string} type - Type of node\n * @param {string} raw - Raw text of node\n * @param {Context} context - context of the node\n * @return {TxtNode} Created TxtNode\n */\nexport function createInlineNode(type, raw, context) {\n  assert(!raw.match(/[\\r\\n]/));\n\n  return {\n    type: type,\n    raw: raw,\n    range: [context.startIndex, context.startIndex + raw.length],\n    loc: {\n      start: {\n        line: context.lineNumber,\n        column: context.startColumn,\n      },\n      end: {\n        line: context.lineNumber,\n        column: context.startColumn + raw.length,\n      },\n    },\n  };\n}\n\n/**\n * create context from Line.\n * @param {Line} line - Line object\n * @param {number} [offset=0] - Column offset\n * @return {Context} Created Context object\n */\nexport function contextFromLine(line, offset=0) {\n  return {\n    startIndex: line.startIndex + offset,\n    lineNumber: line.lineNumber,\n    startColumn: offset,\n  };\n}\n\n/**\n * create new context with offset from original context.\n * @param {Context} originalContext - Original Context object\n * @param {number} offset - Column offset\n * @return {Context} New Context object\n */\nexport function offsetContext(originalContext, offset) {\n  const newContext = Object.assign({}, originalContext);\n  newContext.startIndex += offset;\n  newContext.startColumn += offset;\n  return newContext;\n}\n\n/**\n * create new context with unescapeBraces = true.\n * @param {Context} originalContext - Original Context object\n * @return {Context} New Context object\n */\nexport function contextNeedsUnescapeBraces(originalContext) {\n  const newContext = Object.assign({}, originalContext);\n  newContext.unescapeBraces = true;\n  return newContext;\n}\n\n/**\n * create new context with unescapeBrackets = true.\n * @param {Context} originalContext - Original Context object\n * @return {Context} New Context object\n */\nexport function contextNeedsUnescapeBrackets(originalContext) {\n  const newContext = Object.assign({}, originalContext);\n  newContext.unescapeBrackets = true;\n  return newContext;\n}\n"],"file":"parser-utils.js"}