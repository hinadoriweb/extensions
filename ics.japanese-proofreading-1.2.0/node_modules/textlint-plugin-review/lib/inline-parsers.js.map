{"version":3,"sources":["../src/inline-parsers.js"],"names":["parseLine","line","isComment","parseText","text","InlineParsers","bou","inlineTextTagParser","Syntax","Bouten","ami","Amikake","u","Underline","b","Bold","i","Italic","strong","Strong","em","Emphasis","tt","Teletype","tti","TeletypeItalic","ttb","TeletypeBold","tcy","TateChuYoko","kw","parseKeywordTag","ruby","parseRubyTag","href","parseHrefTag","chap","inlineNonTextTagParser","Reference","title","chapref","list","img","table","hd","column","fn","code","withValue","Code","comment","Comment","uchar","UnicodeChar","br","Break","icon","Icon","m","Math","raw","Raw","inlineParser","tag","context","node","value","content","type","parseInlineNonTextTag","parseInlineTextTag","fullText","strContext","index","strNode","children","Keyword","pieces","split","word","length","alt","Href","url","label","labelOffset","indexOf","Ruby","rubyBase","rubyText","match","nodes","precedingText","push","parser","name","followingText"],"mappings":"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","sourcesContent":["// LICENSE : MIT\n'use strict';\nimport assert from 'assert';\nimport { Syntax } from './mapping';\nimport {\n  parseBlockArg, findInlineTag, createNodeFromChunk, createCommentNodeFromLine, createStrNode,\n  createInlineNode, contextFromLine, offsetContext, contextNeedsUnescapeBraces, unescapeValue\n} from './parser-utils';\n\n/**\n * parse a line.\n * @param {Line} line - line to parse\n * @return {[TxtNode]} TxtNodes\n */\nexport function parseLine(line) {\n  if (line.isComment) {\n    return [createCommentNodeFromLine(line)];\n  }\n\n  return parseText(line.text, contextFromLine(line));\n}\n\nconst InlineParsers = {\n  // text tags\n  bou:     inlineTextTagParser(Syntax.Bouten),\n  ami:     inlineTextTagParser(Syntax.Amikake),\n  u:       inlineTextTagParser(Syntax.Underline),\n  b:       inlineTextTagParser(Syntax.Bold),\n  i:       inlineTextTagParser(Syntax.Italic),\n  strong:  inlineTextTagParser(Syntax.Strong),\n  em:      inlineTextTagParser(Syntax.Emphasis),\n  tt:      inlineTextTagParser(Syntax.Teletype),\n  tti:     inlineTextTagParser(Syntax.TeletypeItalic),\n  ttb:     inlineTextTagParser(Syntax.TeletypeBold),\n  tcy:     inlineTextTagParser(Syntax.TateChuYoko),\n\n  // partially text tags\n  kw:      parseKeywordTag,\n  ruby:    parseRubyTag,\n  href:    parseHrefTag,\n\n  // non-text tags\n  chap:    inlineNonTextTagParser(Syntax.Reference),\n  title:   inlineNonTextTagParser(Syntax.Reference),\n  chapref: inlineNonTextTagParser(Syntax.Reference),\n  list:    inlineNonTextTagParser(Syntax.Reference),\n  img:     inlineNonTextTagParser(Syntax.Reference),\n  table:   inlineNonTextTagParser(Syntax.Reference),\n  hd:      inlineNonTextTagParser(Syntax.Reference),\n  column:  inlineNonTextTagParser(Syntax.Reference),\n  fn:      inlineNonTextTagParser(Syntax.Reference),\n\n  code:    withValue(inlineNonTextTagParser(Syntax.Code)),\n  comment: withValue(inlineNonTextTagParser(Syntax.Comment)),\n  uchar:   inlineNonTextTagParser(Syntax.UnicodeChar),\n  br:      inlineNonTextTagParser(Syntax.Break),\n  icon:    inlineNonTextTagParser(Syntax.Icon),\n  m:       inlineNonTextTagParser(Syntax.Math),\n  raw:     inlineNonTextTagParser(Syntax.Raw),\n};\n\n/**\n * get new inline tag parser to get value attribute.\n * @param {function} inlineParser - Parser function of a inline tag\n * @return {function} parser function\n */\nfunction withValue(inlineParser) {\n  return (tag, context) => {\n    const node = inlineParser(tag, context);\n    node.value = unescapeValue(tag.content.raw, context);\n    return node;\n  };\n}\n\n/**\n * get non-text tag parser function.\n * @param {string} type - type of tag\n * @return {function} parser function\n */\nfunction inlineNonTextTagParser(type) {\n  return (tag, context) =>\n    parseInlineNonTextTag(type, tag, context);\n}\n\n/**\n * get text tag parser function.\n * @param {string} type - type of tag\n * @return {function} parser function\n */\nfunction inlineTextTagParser(type) {\n  return (tag, context) =>\n    parseInlineTextTag(type, tag, context);\n}\n\n/**\n * parse non-text tag, which has no child.\n * @param {string} type - type of tag\n * @param {Tag} tag - tag to parse\n * @param {Context} context - context of the node\n * @return {TxtNode}\n */\nfunction parseInlineNonTextTag(type, tag, context) {\n  const node = createInlineNode(type, tag.fullText, context);\n  return node;\n}\n\n/**\n * parse text tag, which has child Str node.\n * @param {string} type - type of tag\n * @param {Tag} tag - tag to parse\n * @param {Context} context - context of the node\n * @return {TxtNode}\n */\nfunction parseInlineTextTag(type, tag, context) {\n  const node = createInlineNode(type, tag.fullText, context);\n  const strContext = offsetContext(context, tag.content.index);\n  const strNode = createStrNode(tag.content.raw, strContext);\n  node.children = [strNode];\n  return node;\n}\n\n/**\n * parse @<kw>{} tag.\n * @param {Tag} tag - tag to parse\n * @param {Context} context - context of the node\n * @return {TxtNode}\n */\nfunction parseKeywordTag(tag, context) {\n  const node = createInlineNode(Syntax.Keyword, tag.fullText, context);\n\n  const pieces = tag.content.raw.split(/\\s*,\\s*/, 2);\n  const word = pieces[0];\n  if (pieces.length === 2) {\n    node.alt = pieces[1];\n  }\n\n  const strNode = createStrNode(word, offsetContext(context, tag.content.index));\n  node.children = [strNode];\n\n  return node;\n}\n\n/**\n * parse @<href>{} tag.\n * @param {Tag} tag - tag to parse\n * @param {Context} context - context of the node\n * @return {TxtNode}\n */\nfunction parseHrefTag(tag, context) {\n  const node = createInlineNode(Syntax.Href, tag.fullText, context);\n\n  const pieces = tag.content.raw.split(/\\s*,\\s*/, 2);\n  const url = pieces[0];\n  let label;\n  let labelOffset;\n  if (pieces.length === 2) {\n    label = pieces[1];\n    labelOffset = tag.content.index + tag.content.raw.indexOf(label, url.length);\n    assert(labelOffset >= tag.content.index);\n  } else {\n    label = url;\n    labelOffset = tag.content.index;\n  }\n\n  const strContext = offsetContext(context, labelOffset);\n  const strNode = createStrNode(label, strContext);\n\n  node.url = url;\n  node.children = [strNode];\n\n  return node;\n}\n\n/**\n * parse @<ruby>{} tag.\n * @param {Tag} tag - tag to parse\n * @param {Context} context - context of the node\n * @return {TxtNode}\n */\nfunction parseRubyTag(tag, context) {\n  const node = createInlineNode(Syntax.Ruby, tag.fullText, context);\n  const pieces = tag.content.raw.split(/\\s*,\\s*/, 2);\n  assert(pieces.length === 2);\n  const rubyBase = pieces[0];\n  const rubyText = pieces[1];\n\n  const strNode = createStrNode(rubyBase, offsetContext(context, tag.content.index));\n\n  node.rubyText = rubyText;\n  node.children = [strNode];\n\n  return node;\n}\n\n/**\n * parse inline tags and StrNodes from line.\n * @param {string} text - Text of the line\n * @param {Context} context - context of the node\n * @return {[TxtNode]} TxtNodes in the line\n */\nexport function parseText(text, context) {\n  assert(!text.match(/[\\r\\n]/));\n\n  const nodes = [];\n  let tag;\n  while (tag = findInlineTag(text)) {\n    if (tag.precedingText !== '') {\n      const node = createStrNode(tag.precedingText, context);\n      nodes.push(node);\n      context = offsetContext(context, node.raw.length);\n    }\n\n    const parser = InlineParsers[tag.name];\n    if (parser) {\n      const node = parser(tag, contextNeedsUnescapeBraces(context));\n      nodes.push(node);\n    }\n\n    context = offsetContext(context, tag.fullText.length);\n    text = tag.followingText;\n  }\n\n  if (text.length) {\n    const node = createStrNode(text, context);\n    nodes.push(node);\n  }\n\n  return nodes;\n}\n\n"],"file":"inline-parsers.js"}