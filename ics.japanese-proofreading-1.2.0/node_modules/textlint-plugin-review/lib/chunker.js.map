{"version":3,"sources":["../src/chunker.js"],"names":["ChunkTypes","Paragraph","Heading","UnorderedList","OrderedList","DefinitionList","Block","Comment","parseAsChunks","text","lines","match","startIndex","currentChunk","chunks","reduce","result","currentLine","index","line","raw","replace","lineNumber","parseLine","length","forEach","chunk","firstLineIndex","lastLineIndex","slice","join","startsWith","isComment","push","createChunk","type","flushChunk","endsWith","firstLine"],"mappings":"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","sourcesContent":["// LICENSE : MIT\n'use strict';\n\nexport const ChunkTypes = {\n  Paragraph: 'Paragraph',\n  Heading: 'Heading',\n  UnorderedList: 'UnorderedList',\n  OrderedList: 'OrderedList',\n  DefinitionList: 'DefinitionList',\n  Block: 'Block',\n\n  // NOTE: Comment chunk means an independent comment line. Other chunks may include comment lines.\n  Comment: 'Comment',\n};\n\n/**\n * parse text and return array of chunks.\n * @param {string} text\n * @return {[Chunk]}\n */\nexport function parseAsChunks(text) {\n  const lines = text.match(/(?:.*\\r?\\n|.+$)/g); // split lines preserving line endings\n  //console.log(lines);\n  var startIndex = 0;\n  var currentChunk = null;\n\n  const chunks = lines.reduce(function (result, currentLine, index) {\n    const line = {\n      raw: currentLine, // with line endings\n      text: currentLine.replace(/\\r?\\n$/, ''), // without line endings\n      lineNumber: index + 1,\n      startIndex: startIndex,\n    };\n    parseLine(result, line);\n    startIndex += currentLine.length;\n    return result;\n  }, []);\n\n  chunks.forEach(chunk => {\n    const firstLineIndex = chunk.lines[0].lineNumber - 1;\n    const lastLineIndex = chunk.lines[chunk.lines.length - 1].lineNumber - 1;\n    chunk.raw = lines.slice(firstLineIndex, lastLineIndex + 1).join('');\n  });\n\n  return chunks;\n\n  function parseLine(result, line) {\n    // comment\n    // NOTE: comment does not break current chunk, i.e. a block can contain comments in its body.\n    if (line.text.startsWith('#@')) {\n      line.isComment = true;\n      if (currentChunk) {\n        currentChunk.lines.push(line);\n      } else {\n        // A comment line corresponds to a Comment chunk.\n        result.push(createChunk(ChunkTypes.Comment, line));\n      }\n\n      return;\n    }\n\n    // block content\n    if (currentChunk && currentChunk.type === ChunkTypes.Block) {\n      currentChunk.lines.push(line);\n      if (line.text.startsWith('//}')) {\n        flushChunk(); // end of block\n      }\n\n      return;\n    }\n\n    // block open\n    if (line.text.match(/^\\/\\/\\w+/)) {\n      flushChunk();\n      const chunk = createChunk(ChunkTypes.Block, line);\n      result.push(chunk);\n      if (line.text.endsWith('{')) {\n        // block with open and end tags, e.g. //list, //emlist, etc.\n        currentChunk = chunk;\n      }\n\n      return;\n    }\n\n    // heading\n    if (line.text.startsWith('=')) {\n      flushChunk();\n      result.push(createChunk(ChunkTypes.Heading, line));\n      return;\n    }\n\n    // unordered list\n    if (line.text.match(/^\\s+\\*+\\s+/)) {\n      if (currentChunk && currentChunk.type === ChunkTypes.UnorderedList) {\n        currentChunk.lines.push(line);\n      } else {\n        flushChunk();\n        currentChunk = createChunk(ChunkTypes.UnorderedList, line);\n        result.push(currentChunk);\n      }\n\n      return;\n    }\n\n    // ordered list\n    if (line.text.match(/^\\s+\\d+\\.\\s+/)) {\n      if (currentChunk && currentChunk.type === ChunkTypes.OrderedList) {\n        currentChunk.lines.push(line);\n      } else {\n        flushChunk();\n        currentChunk = createChunk(ChunkTypes.OrderedList, line);\n        result.push(currentChunk);\n      }\n\n      return;\n    }\n\n    // definition list\n    if (line.text.match(/^\\s+:\\s+/)) {\n      if (currentChunk && currentChunk.type === ChunkTypes.DefinitionList) {\n        currentChunk.lines.push(line);\n      } else {\n        flushChunk();\n        currentChunk = createChunk(ChunkTypes.DefinitionList, line);\n        result.push(currentChunk);\n      }\n\n      return;\n    }\n\n    // continuation line of definition list\n    if (line.text.match(/^\\s+/) &&\n        currentChunk && currentChunk.type === ChunkTypes.DefinitionList) {\n      currentChunk.lines.push(line);\n      return;\n    }\n\n    // empty line\n    if (line.text === '') {\n      flushChunk();\n      return;\n    }\n\n    // normal string\n    if (currentChunk && currentChunk.type === ChunkTypes.Paragraph) {\n      currentChunk.lines.push(line);\n    } else {\n      flushChunk();\n      currentChunk = createChunk(ChunkTypes.Paragraph, line);\n      result.push(currentChunk);\n    }\n  }\n\n  function flushChunk() {\n    currentChunk = null;\n  }\n\n  function createChunk(type, firstLine) {\n    return {\n      type: type,\n      lines: [firstLine],\n    };\n  }\n}\n"],"file":"chunker.js"}